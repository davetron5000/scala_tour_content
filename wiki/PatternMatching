h1. The Gist

"Pattern Matching":http://www.scala-lang.org/node/120 gives a very gentle introduction to Scala's @match@ and @case@ keywords

h1. My Interpretation

Scala's @match@ keyword is akin to Java's @switch@ statement, however it is *far* more powerful.

To get the flavor of the syntax, here's how you might translate the only real values in computer programming into English:

<script src="http://gist.github.com/154841.js"></script>

Java could do this pretty easily, however Java is limited to primitive types and enumerations.  In Scala, you can use pretty much anything.  Suppose you wish to translate English words like "some", "one" and "none" into UML-type quantifiers.  In Java, you would need either an enumeration or a large @if-then-else@ statement.  In Scala, we can use @match@:

<script src="http://gist.github.com/154842.js"></script>

This, alone, is pretty useful.  However, we can make this even more dynamic.  Suppose we want our function to also translate numbers into exact amounts (e.g. @approximate(34)@ yields @34@) and we want to handle booleans, where a @true@ is @1@ and a @false@ is @0..1@.  This would be some ugly Java code.

<script src="http://gist.github.com/154843.js"></script>

Scala's @match@ and @case@ statements take care of all the casting.  Yes, this is type safe code!

This construct is quite powerful.  [w:CaseClasses] shows another way to use it to keep your code clean and clear.

h1. My Thoughts on this Feature

I almost *never* use @switch@ statements in Java, because they are essentially useless.  Even if all it did here is get rid of annoying @if-then-else@ blocks, I'd call it a win.  As it stands, this is one of the coolest features of Scala and a *really* cool thing to have that takes advantage of the type information we get via static typing.
